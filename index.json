[{"content":"","date":"16 February 2023","permalink":"/tags/disk/","section":"Tags","summary":"","title":"disk"},{"content":"","date":"16 February 2023","permalink":"/","section":"Lun Jiang","summary":"","title":"Lun Jiang"},{"content":"","date":"16 February 2023","permalink":"/tags/open-source/","section":"Tags","summary":"","title":"open source"},{"content":"","date":"16 February 2023","permalink":"/tags/page/","section":"Tags","summary":"","title":"page"},{"content":"","date":"16 February 2023","permalink":"/tags/storage/","section":"Tags","summary":"","title":"storage"},{"content":"Todo: work in progress.\ndisk oriented disk oriented # What a storage system provides, is interacting with disk. That\u0026rsquo;s the system we called database, store, block or small file store, log, persist queue. The disk is a block device, so the most efficient way to interact with disk is read/write a certain length of bytes, that means don\u0026rsquo;t read a byte, a bit, read more at a time. The specific length is usually 4KB, 8KB, 16KB, it depends on disk property and usage of our upper layer system. But no matter what size it is, we called it a page. The page could be fixed length, or not. Experience shows that fix length means indexable, for example, in http2 protocol, the frame header are 9 bytes, it\u0026rsquo;s convenient to parse, it\u0026rsquo;s much easier to skip to the specific content with a certain offset. You can image if you skip 1 byte, that is the package size, if you skip 3 byte, it\u0026rsquo;s the package type, if you skip 6 bytes, it\u0026rsquo;s the package checksum.\nTherefore, the disk basically split into pages for an application. As the basic storage unit, we fill content to the pages, it could be a tuple for RDB, a log entry for write ahead log, a offset number for B+ tree node, or a simple chunk for a file, even a plain blob.\nMost of the time, we design the page as self-contained, that says a page contains some meta information about itself, like the page size, page type, page id, but just in most of the case. I talk about it because I think it as a kind of primitive to construct storage system, if we master the principles, we can design and implement a storage system for a specific use.\nLet\u0026rsquo;s talk more about pages. The pages are usually indexed by directory, which records all the page positions and page data ranges, for example, the page No.23 is stored at position 42312 or position #5, it\u0026rsquo;s range is apple ~ application. But Not all the page content are sequential, it could be arranged by hash. Think about the mysql database, it provides B+ tree index and hash index. The main difference is sequential structure provides ability to range scan, but hash index could be faster. Using a directory to index the page is called page heap.\nTo track a page in directory, we need record the content of the page and whether the page is empty.\ntransaction transaction # implementation: innodb implementation: innodb # implementation: leveldb implementation: leveldb # graph LR A(user) -- put/get -- B(leveldb) B -- C(memtable) B -- D(sstable) B -- E(write ahead log) D -- F(disk)  implementation: boltdb implementation: boltdb # implementation: badgerdb implementation: badgerdb # ","date":"16 February 2023","permalink":"/contribute/storage/","section":"Code Space","summary":"work in progress","title":"Storage Engine: from Primitives to Implementation"},{"content":"","date":"16 February 2023","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"16 February 2023","permalink":"/tags/transaction/","section":"Tags","summary":"","title":"transaction"},{"content":"","date":"16 February 2023","permalink":"/tags/consensus/","section":"Tags","summary":"","title":"consensus"},{"content":"","date":"16 February 2023","permalink":"/tags/consistency/","section":"Tags","summary":"","title":"consistency"},{"content":"","date":"16 February 2023","permalink":"/tags/distributed-system/","section":"Tags","summary":"","title":"distributed system"},{"content":"","date":"16 February 2023","permalink":"/tags/fault-tolerant/","section":"Tags","summary":"","title":"fault tolerant"},{"content":"","date":"16 February 2023","permalink":"/tags/paper/","section":"Tags","summary":"","title":"paper"},{"content":" Original: \u0026ldquo;In Search of an Understandable Consensus Algorithm (Extended Version)\u0026rdquo;\nAuthors: Diego Ongaro and John Ousterhout (Stanford University)\n introduce introduce # Raft is a consensus algorithm widely used in industry. Another widely used available algorithm is called paxos, but the original paper \u0026lsquo;paxos made simple\u0026rsquo; doesn\u0026rsquo;t provide enough details about how to handle stream replication problem(replicate state machine), it talks about the single decree problem which is mainly about how to decide a certain value among a couple of nodes. The real applied algorithm is called multi-paxos, however, the nature of multi paxos in my opinion is almost the same with raft, the main difference is in leader election.\nbackground background # We want to copy a stream to 3~5 nodes(which we called RSM, replicate state machine problem).\nThe critical point is all the nodes should keep the same sequence, that means same data unit, same order. For example, think about a stream of number 51348, every node should persist the same sequence 51348, 53148 and 51148 is wrong.\nAccording to some experience from building practical real world paxos application, we find multi paxos need to elect a leader to improve performance(limit the Round Trip of replication to 1). Diego catch up a great idea: why not split the leader election, the real replicate progress as different parts to make it much clear? That\u0026rsquo;s raft, a practical version of multi paxos, which the author declare more understandable.\nThe result is fault tolerant, which can tolerate less than half of the nodes fails. So every time we accept a request, we don\u0026rsquo;t need to copy to all the nodes, we just replicate to majority of nodes and response immediately to improve performance.\nhow to reach consensus how to reach consensus # First of all, which we called leader, primary, master is exactly the same thing.\nWhen we want to replicate a stream, it\u0026rsquo;s always difficult to figure out how to reach a consensus for all the nodes in a specific issue, the problem is a stream includes a sequence of issues, that means a sequence of consensus need to be deal with, which sounds like a mess.\nHowever, if we have a leader, life becomes easier: all the nodes just follow the leader, replicate the stream element one by one according to leader, no coordination at all, if majority of follower nodes get the replica successfully, this replication turn has finished. An potential problem is the slow leader could become the bottleneck, which is a problem of raft.\nbut where is our leader but where is our leader # Let\u0026rsquo;s elect, everyone nominate himself as a leader, to make it more understandable, we called it president, everyone wants to be president, they all know the current term, for example, the current president is Baiden, the term is 47, in brief is Baiden is the 47th US president. If I want to be the next president, I will be the 48th president, so I nominate myself as 48th president, and someone like me is called the candidate. There is something to decide who can be the next president, in reality, it\u0026rsquo;s the speech, in raft, it\u0026rsquo;s who has more valid stream elements. Since it\u0026rsquo;s a stream replicate system, we compare the length of streams in all the nodes, the longest one should be the leader, so we compared last log index, if the log index is 6, it should longer than log with index 5. In the other hand, for every term, we have only 1 president, a president could be 47th, 48th, but 47th president could not be Trump and Baiden. So we compare the president term at the same time. if a node has term 48 logs, it should has newer logs than a node has only term 20 logs. In conclusion, every node try to be the president, but only one of them could be the next president. they will tell the others his expect term and his last log information, the log info includes log index and the term. The node who has the latest log, will become the next president with his expected term. Since the leader replicate the data to majority of nodes, the candidate only need to win the majority of the nodes instead all the nodes to be chosen.\nhow leader works how leader works # The president broadcast all request to the other nodes with its own term and the global sequential number, every log element has a term and an index number. In the real world, a president can propose a new act with his term and the act number, for every term there is only one president, which ensure if the term and index is the same, the log element could be the same, because a president could not say his 38th act is A, and his 38th act is also B. Notice that we could have more than president at the same time, but we have exact 1 president in the same term. If half of the nodes persist a specific element and response president, the president will say, ok, the act 38 starts work now, it\u0026rsquo;s a consensus.\nwhat if the leader fails what if the leader fails # If the president dies, maybe a terrorist assault, a well-known scandal or a traffic accident, the other nodes would not get acts from president any more, they could not even hear the president, which we called \u0026lsquo;lose the heartbeat\u0026rsquo;, they would join the election, nominate themselves. However, how about the log sequence? The next president will find some nodes(like original leader) has longer log than him, some nodes has shorter log than him, but since he can become the leader, he must has all log which has become a consensus(accept by majority), so nothing lost if the president just handle new request and ignore the longer nodes. The president try to cover all the newer logs in the nodes which has longer logs, and fill the the nodes which has shorter logs. No matter how the original log sequence it looks like, every node would have the same log sequence with leader. That\u0026rsquo;s what we called strong leadership. But wait a minute, if the president cover the longer node, will something be lost? No, since the president could become a president, it must hold the logs commit before, in reality, the longer logs includes the elements haven\u0026rsquo;t reach a consensus. But if the president contains some log elements which haven\u0026rsquo;t commit, it will still replicate this elements left.\nLet\u0026rsquo;s think about a 1 node application, if we issue a write request, the node could shutdown before persist the write or after the persist, but the client don\u0026rsquo;t know, the client don\u0026rsquo;t get the response, so it feel like the write operation fails. Since the president in a 3 nodes system hasn\u0026rsquo;t response the client yet, if could have persisted the write or not, thus the president can cover the other longer nodes, and submit the log elements which even haven\u0026rsquo;t commit.\nthe whole progress the whole progress # At the very beginning, we have some nodes, they all want to be the president to handle the out world request, if they have a president, they act like single one node, act as a whole. the system will keep running, if minority of the nodes fail, nothing lost, nothing broken in the perspective of out world request.\nIn order to be a president, the node need to propose his next term, if current president is 48th, and the node propose 42th, that means the node fall behind, the other node will refuse him. The node need to compare his latest log with the others too, because it\u0026rsquo;s a stream replicate system, we want the log to be highly reliable, nothing lost. If the node has newer log against the majority of the nodes, it could be voted as the next president. The reason of majority is we want to tolerate less than half of the nodes fail, and that also need the president replicate the data to a majority of nodes to promise the data will always survive.\nThe president broadcast log elements with their president term and log index, the log index is just like the index of an array to provide a sequence number. The president force all the other nodes keep the same log with him, and that\u0026rsquo;s how they reach consensus.\nIf a new president occurs, it would find himself has longer logs than some nodes, or has shorter los than some nodes too. However, it always try to make the other nodes persist the same logs with him, if the other nodes have different logs, cover them. The method to compare a specific log element is the term and sequential number, if term and N.O. is the same, the log must be the same, because a president will never say act 123 is A and act 123 is B at the same time, and there is only 1 president in every certain term.\n try to read the paper before read the article, if you feel blocked, get back here instead of reading the article without reading the paper.\na visible progress of raft could be found here: raftThe Raft Consensus Algorithm\n ","date":"16 February 2023","permalink":"/paper/raft/","section":"Papers","summary":"Replicate is a common topic in distributed system, algorithms like paxos and its variants are difficult to understand, lack of details, but raft can help","title":"Paper: Raft Consensus Algorithm"},{"content":"","date":"16 February 2023","permalink":"/tags/protocol/","section":"Tags","summary":"","title":"protocol"},{"content":"","date":"16 February 2023","permalink":"/tags/raft/","section":"Tags","summary":"","title":"raft"},{"content":"","date":"16 February 2023","permalink":"/tags/replicate/","section":"Tags","summary":"","title":"replicate"},{"content":"","date":"13 February 2023","permalink":"/tags/cloud-native/","section":"Tags","summary":"","title":"cloud native"},{"content":"","date":"13 February 2023","permalink":"/tags/control-plane/","section":"Tags","summary":"","title":"control plane"},{"content":"","date":"13 February 2023","permalink":"/tags/controller/","section":"Tags","summary":"","title":"controller"},{"content":"","date":"13 February 2023","permalink":"/tags/etcd/","section":"Tags","summary":"","title":"etcd"},{"content":"","date":"13 February 2023","permalink":"/tags/kubernetes/","section":"Tags","summary":"","title":"kubernetes"},{"content":"introduce introduce # ","date":"13 February 2023","permalink":"/contribute/kube/apiserver/","section":"Code Space","summary":"placeholder","title":"Kubernetes: API Server"},{"content":"introduce introduce # ","date":"13 February 2023","permalink":"/contribute/kube/controller/","section":"Code Space","summary":"placeholder","title":"Kubernetes: Controller"},{"content":"","date":"13 February 2023","permalink":"/tags/message-queue/","section":"Tags","summary":"","title":"message queue"},{"content":" Original: \u0026ldquo;The Design of a Practical System for Fault-Tolerant Virtual Machines\u0026rdquo;\nAuthors: Daniel J. Scales, Mike Nelson, and Ganesh Venkitachalam (VMware, Inc{scales,mnelson,ganesh}@vmware.com)\n introduce introduce # This paper (virtual machine fault tolerant) I think is one of the best paper for someone who wants to step into distributed system. It provides some basic opinions about how to replicate state.\nbackground background # The background of this paper is to design a fault tolerant virtual machine service, and the most common idea for fault tolerant is to replicate, so they talk about how to replicate computation.\nIf these terminology sounds a bit scare, like what the f**k they are? can you just say something more understandable like what a human can figure out, don\u0026rsquo;t worry, it\u0026rsquo;s really easy, assume you have a windows os, you don\u0026rsquo;t want it to stop running while losing power connection or want it to survive even from an earthquake. so you just run 2 windows in different computers simultaneously. Now we have 2 running windows os, if one of them stops, the other one will still keep running, thus our excel application can survive, however, we want these 2 windows run the same excel, handle the same row, the critical part becomes how to synchronize the state between 2 windows, the problem is what we called replicated state machine.\nThe nature is how to replicate state sequence, and the result is a fault tolerant computation system.\nwhat we have what we have # We have 2 instances(virtual machines, image it as windows).\nOne called primary, the other one called backup.\nThey are connected via network, they shared a net disk.\nwhat to replicate what to replicate # But the first problem is what to replicate?\n the sequence of the current result. include the registers, memory bytes, and all what we have modified. That\u0026rsquo;s not a good idea, because the data is too large. the sequence of the operation. like we clicked some place. The real operation is the underlying instructions in the execution stack I guess. It doesn\u0026rsquo;t matter if our interests is just try to understand the replication instead of virtual machine. A terrible thing is operating system has some uncertain events like time and IO interrupt, as the result, this uncertain things need to be translated to certain things. They have a professional terminology called deterministic state machine to describe this uncertain operation, a common example is now function, assume you want to replicate the data between 2 database, set and get operation is certain, but now system call is uncertain.  how to replicate (which called protocol) how to replicate (which called protocol) # The whole progress looks like this:\nThe clients send requests to the primary,\nprimary translate it to a couple of certain operations,\nprimary send it to the backup,\nbackup responds ack,\nprimary execute the request and response client,\ndone.\nWe have some problems here,\nThe first one is what if primary runs really fast, the backup falls behind a lot. sounds like after the primary respond, the backup found it will take him 2 days to catch up with the primary, that means if our primary stops running, we will lose our recent 2 days work!\nThe idea is to create a fixed length buffer to store the operations. We can assume the buffer can store 1 minutes work at most, if it\u0026rsquo;s full, the primary should pause and wait the backup to catch up with him. it\u0026rsquo;s like a block queue in inter process communication or a fixed length channel instance in golang. The purpose is to synchronize the speed of both sides.\nAnother problem is what if primary fails. If some machine fails, fault tolerant design starts work.\nIf the backup stops, everything seems still work, we fallback to the common scene: we have only one computer, it runs windows, it works.\nIf the primary stops, we want to shift to backup, but first, how does the backup recognize the primary has stopped. Just build a heartbeat to sense each other. If the primary find no heartbeat from backup, it can create a new backup. If the backup find no heartbeat, it try to become the primary, and repeat the behavior of the primary.\nThe progress of becoming a primary is usually called election in some consensus algorithm, vmft use a simple method to elect, use a cas(compare and set/swap) operation to write to a shared net disk. The winner of election is called primary, leader, master, main\u0026hellip;\nBy the way, to discover to the broken nodes in a system,\nwe use heartbeat,\nif we have only 2 nodes, they can heartbeat each other,\nif we have 3 or 5 nodes for a certain usage, we can create full connection among them,\nif we have unknown numbers of nodes, we can create a third party monitor service to probe all of the nodes.\ncompare with other system compare with other system # GFS:\nvmft uses a more underlying model to replicate, it directly replicate the virtual machine, it theoretically means it can replicate all application run in the virtual machine like excel, database, game, but noticed that it must runs in low performance too.\nGFS is used to replicate bytes block specifically, that means it replicate in the application level. however, it provides no consistency promise while vmft says it will return only the primary and the backup persist successfully.\nThat means the data stored in GFS could be not the same at all, but application runs in vmft will always keep the same.\nsomething else something else # There are bunch of things we don\u0026rsquo;t care about, like the virtual machines specific improvement. Our interest focus on the general replication.\nReplicate the computation is not a good idea in some ways. because computation itself is expensive and it takes a lot of resources include not only the CPU, but also expensive memory, IO bandwidth. Calculate separately and replicate the result of a short period would be more competitive.\n","date":"13 February 2023","permalink":"/paper/vmft/","section":"Papers","summary":"replicate computation is complex, paper vmft try to introduce the work to replicate virtual machine","title":"Paper: Virtual Machine Fault Tolerant"},{"content":"","date":"13 February 2023","permalink":"/tags/partition/","section":"Tags","summary":"","title":"partition"},{"content":"Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet # Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean in eleifend justo, vestibulum congue lacus. Quisque est libero, lacinia sed placerat ac, interdum id urna. Nulla venenatis volutpat libero, in laoreet leo fringilla eget. Etiam consequat sed nisi sit amet interdum. Pellentesque ullamcorper at turpis in ultrices. Pellentesque et elit mauris. Aenean eu augue sit amet nunc interdum ultricies. Aenean eleifend consectetur sapien vitae consectetur. Donec risus mauris, finibus at condimentum at, lacinia sit amet neque. Nulla facilisi. Suspendisse sollicitudin dolor quis eros tempor, a tempus ex varius.\n","date":"13 February 2023","permalink":"/contribute/queue/","section":"Code Space","summary":"Message Queue is a separate server to store message with FIFO sequence.","title":"Queue: Nats, NSQ and Kafka"},{"content":"","date":"13 February 2023","permalink":"/tags/replication/","section":"Tags","summary":"","title":"replication"},{"content":"","date":"12 February 2023","permalink":"/about/","section":"Lun Jiang","summary":"","title":"About me"},{"content":"","date":"12 February 2023","permalink":"/tags/cloud/","section":"Tags","summary":"","title":"cloud"},{"content":"","date":"12 February 2023","permalink":"/tags/container/","section":"Tags","summary":"","title":"container"},{"content":"Todo: work in progress.\nintroduce introduce # system call system call # ","date":"12 February 2023","permalink":"/contribute/container/","section":"Code Space","summary":"work in progress","title":"Container: Namespace, Cgroups and Shipping"},{"content":"Todo: Collate pieces. Make it an article for dummy.\nruntime runtime #  chan: - cpuprof: hashmap: - lfstack: 无锁栈，使用 cas lock_futex: lock 实现，使用 cas lock_sema: lock 的实现，使用 semaphore malloc: alloc mbarrier: gc-写屏障 mbitmap: gc-bitmap mcache: gc-线程内存块缓存，用于小对象 mcentral: gc-中心缓存(freelist) mfinal: gc-finalizer and block profling，不知道是啥 mfixalloc: gc-固定大小的对象分配 mgc: gc-主文件 mgcmark: gc-标记 mgcsweep: gc-清理 mgcwork: gc-灰色节点的处理队列，BFS 中队列一样的用法。 mheap: heap 实现 mprof: 分配器的 prof 信息 msize: 分配小尺寸 mstats: 内存统计信息，比如堆大小，已分配量 netpoll_epoll: epoll netpoll: - noasm: 就俩函数，都很简单，一个 cmpstring，另一个 bytes_Compare，很值得学习，学习 go:link 和+build 写法 panic: 包含 defer 和 throw 的实现，deferproc parfor: 并行 for 的实现 print1: 包括 print 的所有实现，比如 print([]int{1,2,3}) 的实现 proc: 一切秘密都在这里, gopark, goready proc1: 调度器 race: 竞争检测用的 runtime1: acquirem 和 releasem，分别释放和抓取线程，用来运行 goroutine runtime2: gmp 三个结构体都在这里了，还有 stack，gobuf，lfnode，_defer, _panic 等结构 select: select 的实现 sema: semaphore 实现 sigqueue: 信号处理 slice: - stack1: 运行栈实现，包括栈分配，释放，创建，栈帧布局等。 string: stubs: getg, systemstack, memclr, memmove, gogo, gosave, cas 等存根，真正实现在 asm 汇编里 symtab: 符号表 time: 时间相关，解析等 trace: 一些 追踪事件，可以用于帮助读源码和 debug traceback: type: 类型，包括函数，slice，map，指针等 typekind:  runtime:sync runtime:sync #  cas lock sema  ","date":"12 February 2023","permalink":"/contribute/golang/","section":"Code Space","summary":"Todo: Collate","title":"(cn) Golang Runtime Introduction"},{"content":" 原文开头:\n这几天日本改年号令和说选自万叶集，也想蹭蹭日本人的雅致，第一篇就叫樱之章，取自万叶恋歌的第一章。 万叶集里有一首雷神短歌，\n隐约雷鸣，阴霾天空，但盼风雨来,能留你在此。\n若是觉得有趣，不妨搜索下一句，对比诗经天地合乃敢与君绝，仿佛失去了那种至死不渝的气势，到是多了几分初见的青涩，倘若让我选，或是前者，昙花一刹，胜过万千。\n 关于 艾风逸 关于 艾风逸 # 十多年前年前我就使用艾风逸作为网名，其实他是我想给自己取得名字。我一直觉得父亲取名时迷信鬼神占卜，肤浅幼稚，故而对自己的名字颇为不满。\n风逸的风是指虚无缥缈，存在却又无形的，看不见无处不在却容易被忽略的东西。代指自然规律，又像社会规则这样的看不见的东西。\n小时候我总觉着，大家一直埋头学习，为什么不重新审视一下是否该学习，又该如何学习，该学什么。大家一直学，却从没想过如何学，为何学，所以学习就是一阵风，空气一样无处不在，却没人注意他。\n逸是指灵动跳脱，寓意能看清一切，从而随心所欲。换个说法，想赚钱就能赚到钱，想学啥就能学会，高效学习是自然规律，了解记忆曲线，题海都是对人脑学习规律的理解，赚钱则是对人类世界规则的理解，看很多人利用关系也好，利用资本也罢，都是对看不见的赚钱规则的正确认识。当然这些都只是自己的幻想，因为是名字嘛，所以总有点期望的意思，就像王百万一样。\n有些不知道的，可能会觉着这个名字挺文艺的，其实本人的寓意是这么个意思。\n有意思的是，我曾遇到一个女孩子用水若做名字，可那个女孩子太漂亮，那个年纪也没敢聊两句，想来聊多了又觉得你和她格格不入也没意思就是了。\n这是是我初中时取得昵称。一直用所以挺有感情。我很喜欢这个名字，我是个思想比较开放、自由和激进的人，所以以前，我想以后和谁结婚了，这个名字可以给孩子，如果妈妈喜欢，就随她姓把艾去掉。当然到高中开始已经决定以后不要孩子了。\n十多年过去，物是人非，房子被拆迁了搬走了，小伙伴因为教育分流也不联系了，只有这昵称，却一直被我保留着。\n注:\n原文发布在简书(2019-04-08T21:07:05+0800)，因为麻烦的审核机制已经放弃简书了。后迁到博客，因为所有数据丢失了，博客源码和文章也没有了，从其他网站移植过来。\ncover 上的 summary 是后来补充的。 ","date":"12 February 2023","permalink":"/inspiration/name/","section":"Grocery","summary":"每个人大概都一定程度上不喜欢自己的出身，名字，历史，那些不能掌控的初值。小时候一直想给自己取个新名字，是一种抱怨，无能的人才会抱怨，表达对既定的不满又无力改变；也是一种期盼，包含对的美好祝福。","title":"(cn) 艾风逸: 名字的故事"},{"content":"","date":"12 February 2023","permalink":"/tags/about/","section":"Tags","summary":"","title":"about"},{"content":"","date":"12 February 2023","permalink":"/tags/block-storage/","section":"Tags","summary":"","title":"block storage"},{"content":" The poem are selected from the Book of Poetry which is written in about 500~550 A.D.\nThe original name is \u0026ldquo;诗经：氓\u0026rdquo;.\n Chapter One Chapter One # A man looks attractive comes to me,\nswap my silk with his cloth.\nBut he doesn’t want the silk,\nhe wants me.\nI’m about to accompany with him to the River Qi when he leave,\nbut I keep going until Hill Dunqu.\nI don’t want to delay our marriage inside my heart,\nbut you(the man) never make a formal propose.\nPlease don’t be angry,\nI promise you autumn is our time.\nChapter Two Chapter Two # I miss you so sick,\nI stand in the city wall to look for you,\nI can feel my smile so bright when I find you,\nI can also feel my pain if you don’t appear.\nYou ask for fortune-teller to divine our future, It’s bright,\nso I enter your carriage and get married without doubt.\nChapter Three Chapter Three # When the leaf of mulberry tree hasn’t withered,\nit looks colorful.\n(When I’m still young, I looks beautiful.)\nTurtledove, don’t eat too much mulberry fruit.\nGirl, don’t fall too deep in love.\n(Chinese myth says the turtledove will get poisoning when it eat too much mulberry fruit, perhaps the girl should not fall in love too quickly, it\u0026rsquo;s the poison)\nIf a man fall in love, he can still leave,\nif a woman fall in love, she will get trapped.\n(In the traditional Chinese society, if a woman has married with someone, she is hard to remarry with someone else when divorced, the situation of man is totally different)\nChapter Four Chapter Four # Now the leafs of mulberry has withered,\nthey fall down from the limb.\nSince I came to your family,\nmy life became poor.\nRiver Qi runs day and night,\nit wets the curtain of my carriage (I decide to leave you).\nI have no fault in my behavior,\nbut you are inconsistent.\nChapter Five Chapter Five # After I become your wife, I work hard for our family;\nI sleep late, I wake up early.\n(however, we often have conflicts.)\nSince the verbally abusive ends,\nthe violence starts.\nBrothers are not wise enough,\nlaugh loudly at me.\nI stay alone and calm down to consider about myself,\nhow sad I am!\nChapter Six Chapter Six # River Qi looks so board, but it still has its border.\nSwamp Xi looks so large, but is also has its end.\n(so does our love.)\nI remind of my warm family time,\nwhen I was a little girl.\nEven though once we own the swear and promise from each other,\nwe are apart now,\nI will never think about our experience again,\nit’s end.\n Originally post in medium (2020-10-27T13:17:05) and modified some sentences, link attached as follow: A love story from distant eastern world\n ","date":"12 February 2023","permalink":"/inspiration/meng/","section":"Grocery","summary":"Love is always the topic for us all. It repeats again and again during thousands of years of our journey. It\u0026rsquo;s simple like that, fall in love, together and apart. maybe happy, maybe painful, kinda experience.","title":"Chinese Poem from 1500 Years Ago: An Attractive Man"},{"content":"","date":"12 February 2023","permalink":"/tags/column-storage/","section":"Tags","summary":"","title":"column storage"},{"content":"","date":"12 February 2023","permalink":"/tags/condition-variable/","section":"Tags","summary":"","title":"condition variable"},{"content":"","date":"12 February 2023","permalink":"/tags/culture/","section":"Tags","summary":"","title":"culture"},{"content":"","date":"12 February 2023","permalink":"/tags/garbage-collector/","section":"Tags","summary":"","title":"garbage collector"},{"content":"","date":"12 February 2023","permalink":"/tags/golang/","section":"Tags","summary":"","title":"golang"},{"content":"","date":"12 February 2023","permalink":"/tags/google/","section":"Tags","summary":"","title":"google"},{"content":"","date":"12 February 2023","permalink":"/tags/goroutine/","section":"Tags","summary":"","title":"goroutine"},{"content":"","date":"12 February 2023","permalink":"/tags/japanese/","section":"Tags","summary":"","title":"japanese"},{"content":"introduce introduce # ","date":"12 February 2023","permalink":"/contribute/kube/scheduler/","section":"Code Space","summary":"placeholder","title":"Kubernetes: Scheduler"},{"content":"","date":"12 February 2023","permalink":"/tags/language/","section":"Tags","summary":"","title":"language"},{"content":"","date":"12 February 2023","permalink":"/tags/lock/","section":"Tags","summary":"","title":"lock"},{"content":"","date":"12 February 2023","permalink":"/tags/master-slave/","section":"Tags","summary":"","title":"master-slave"},{"content":"","date":"12 February 2023","permalink":"/tags/memory-allocator/","section":"Tags","summary":"","title":"memory allocator"},{"content":"","date":"12 February 2023","permalink":"/tags/multiplex/","section":"Tags","summary":"","title":"multiplex"},{"content":"","date":"12 February 2023","permalink":"/tags/name/","section":"Tags","summary":"","title":"name"},{"content":"","date":"12 February 2023","permalink":"/tags/newsql/","section":"Tags","summary":"","title":"NewSQL"},{"content":" Original: \u0026ldquo;CockroachDB: The Resilient Geo-Distributed SQL Database\u0026rdquo;\nAuthors: Rebecca Taft, Irfan Sharif, Andrei Matei, Nathan VanBenschoten, Jordan Lewis, Tobias Grieger, Kai Niemi, Andy Woods, Anne Birzin, Raphael Poss, Paul Bardea, Amruta Ranade, Ben Darnell, Bram Gruneir, Justin Jaffray, Lucy Zhang, and Peter Mattis (Cockroach Labs, Inc.)\n introduce introduce # ","date":"12 February 2023","permalink":"/paper/cockroachdb/","section":"Papers","summary":"placeholder","title":"Paper: CockroachDB"},{"content":" Original: \u0026ldquo;The Google File System\u0026rdquo;\nAuthors: Sanjay Ghemawat, Howard Gobioff, and Shun-Tak Leung (Google)\n introduce introduce # requirements requirements # The first requirement is provide some basic function for a storage system:\n read(filename, offset) append(filename, data)  ","date":"12 February 2023","permalink":"/paper/gfs/","section":"Papers","summary":"placeholder","title":"Paper: Google File System"},{"content":" Original: \u0026quot;\u0026quot;\nAuthors:\n introduce introduce # ","date":"12 February 2023","permalink":"/paper/kafka/","section":"Papers","summary":"placeholder","title":"Paper: Kafka Message Queue"},{"content":"introduce introduce # ","date":"12 February 2023","permalink":"/paper/paxos/","section":"Papers","summary":"placeholder","title":"Paper: Paxos Consensus Algorithm and its variants"},{"content":"","date":"12 February 2023","permalink":"/tags/poem/","section":"Tags","summary":"","title":"poem"},{"content":"","date":"12 February 2023","permalink":"/tags/policy/","section":"Tags","summary":"","title":"policy"},{"content":"","date":"12 February 2023","permalink":"/tags/queue/","section":"Tags","summary":"","title":"queue"},{"content":"","date":"12 February 2023","permalink":"/tags/runtime/","section":"Tags","summary":"","title":"runtime"},{"content":"","date":"12 February 2023","permalink":"/tags/scheduler/","section":"Tags","summary":"","title":"scheduler"},{"content":"","date":"12 February 2023","permalink":"/tags/semaphore/","section":"Tags","summary":"","title":"semaphore"},{"content":"","date":"12 February 2023","permalink":"/tags/story/","section":"Tags","summary":"","title":"story"},{"content":"","date":"12 February 2023","permalink":"/tags/thread/","section":"Tags","summary":"","title":"thread"},{"content":"Topics/Hashtags: Language Runtime, Distributed System, Algorithm, Cloud Native, System Programming, Network, Protocol, Storage System, Transaction.\nNot Included: How to use API, How to use library, Language Syntax, Design Pattern, How to use popular Tools(like: git/vim/tmux/vscode/database GUI)\u0026hellip;\n","date":"13 June 2022","permalink":"/contribute/","section":"Code Space","summary":"Topics/Hashtags: Language Runtime, Distributed System, Algorithm, Cloud Native, System Programming, Network, Protocol, Storage System, Transaction.\nNot Included: How to use API, How to use library, Language Syntax, Design Pattern, How to use popular Tools(like: git/vim/tmux/vscode/database GUI)\u0026hellip;","title":"Code Space"},{"content":"Grocery: Inspiration, Opinions, Experience, Art.\n","date":"13 June 2022","permalink":"/inspiration/","section":"Grocery","summary":"Grocery: Inspiration, Opinions, Experience, Art.","title":"Grocery"},{"content":"Make it easy, for human.\n","date":"13 June 2022","permalink":"/paper/","section":"Papers","summary":"Make it easy, for human.","title":"Papers"},{"content":"","date":"1 January 0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1 January 0001","permalink":"/series/","section":"Series","summary":"","title":"Series"}]